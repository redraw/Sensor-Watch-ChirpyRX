{
  "version": 3,
  "sources": ["../src/chirpy-rx.js", "../src/wav-encoder.js", "../src/fft.js", "../src/base64.js", "../src/content-shared.js", "../src/content-activity.js", "../src/content-nanosec.js", "../src/content-ascii.js", "../src/content.js", "../src/app.js"],
  "sourcesContent": ["class ToneStencil {\n  constructor(freq, sampleRate, fftSize) {\n    this.freq = freq;\n    this.bins = getBins(freq, sampleRate, fftSize, true);\n  }\n}\n\nfunction getBins(freq, sampleRate, fftSize, multiple = false) {\n  const bandwidth = sampleRate / fftSize;\n  let midIx = -1;\n  for (let i = 0; i < fftSize / 2; ++i) {\n    if (freq > i * bandwidth && freq <= (i+1) * bandwidth) {\n      midIx = i;\n      break;\n    }\n  }\n  if (multiple) return [midIx - 1, midIx, midIx + 1];\n  else return [midIx];\n}\n\nclass Demodulator {\n\n  constructor({sampleRate, fftSize, toneRate, baseFreq, freqStep, nFreqs}) {\n\n    const bitSize = Math.log(nFreqs - 1) / Math.log(2);\n    if (bitSize != Math.round(bitSize))\n      throw \"nFreqs must be 2^x+1, e.g., 5, 9 or 17\";\n\n    this.bitSize = bitSize;\n    this.sampleRate = sampleRate;\n    this.fftSize = fftSize;\n    this.toneRate = toneRate;\n    this.sampleLenMsec = this.fftSize / this.sampleRate * 1000;\n    this.toneLenMsec = 1000 / this.toneRate;\n\n    this.symFreqs = [];\n    for (let i = 0; i < nFreqs; ++i)\n      this.symFreqs.push(baseFreq + freqStep * i);\n\n    this.stencils = [];\n    for (const freq of this.symFreqs)\n      this.stencils.push(new ToneStencil(freq, sampleRate, fftSize));\n\n    console.log(\"Demodulator params:\", {sampleRate, fftSize, toneRate, baseFreq, freqStep, nFreqs});\n    const bandwidth = sampleRate / fftSize;\n    console.log(\"Bandwidth:\", bandwidth);\n    this.symFreqs.forEach((freq, index) => {\n        let midIx = -1;\n        for (let i = 0; i < fftSize / 2; ++i) {\n            if (freq > i * bandwidth && freq <= (i+1) * bandwidth) {\n                midIx = i;\n                break;\n            }\n        }\n        console.log(`Freq ${freq} (index ${index}): midIx = ${midIx}, bins = [${midIx - 1}, ${midIx}, ${midIx + 1}]`);\n    });\n  }\n\n  detecToneAt(spectra, msec) {\n    const ixAt = Math.round(msec / this.sampleLenMsec);\n    const tone0 = detectTone(spectra[ixAt-1], this.stencils);\n    const tone1 = detectTone(spectra[ixAt], this.stencils);\n    const tone2 = detectTone(spectra[ixAt+1], this.stencils);\n    if (tone0 == tone1 || tone0 == tone2) return tone0;\n    if (tone1 == tone2) return tone1;\n    return -1;\n  }\n\n  findStartMsec(spectra) {\n    let firstMatchIx = -1, lastMatchIx = -1;\n    for (let ix0 = 0; ix0 < spectra.length; ++ix0) {\n      const msec0 = ix0 * this.sampleLenMsec;\n      const ix1 = Math.round((msec0 + this.toneLenMsec) / this.sampleLenMsec);\n      const ix2 = Math.round((msec0 + 2 * this.toneLenMsec) / this.sampleLenMsec);\n      const ix3 = Math.round((msec0 + 3 * this.toneLenMsec) / this.sampleLenMsec);\n      if (ix3 > spectra.length - 1) break;\n      const tone0 = detectTone(spectra[ix0], this.stencils);\n      const tone1 = detectTone(spectra[ix1], this.stencils);\n      const tone2 = detectTone(spectra[ix2], this.stencils);\n      const tone3 = detectTone(spectra[ix3], this.stencils);\n      if (tone0 == this.symFreqs.length - 1 && tone1 == 0 &&\n          tone2 == this.symFreqs.length - 1 && tone3 == 0) {\n        if (firstMatchIx == -1) {\n          firstMatchIx = lastMatchIx = ix0;\n        }\n        else lastMatchIx = ix0;\n      }\n      else if (firstMatchIx != -1) break;\n    }\n\n    if (firstMatchIx == -1) return -1;\n    const midMatchIx = Math.round((firstMatchIx + lastMatchIx) / 2);\n    return Math.floor(midMatchIx * this.sampleLenMsec);\n  }\n\n}\n\nlet v1 = null;\n\nfunction detectTone(spectrum, stencils) {\n\n  if (!v1 || v1.length != stencils.length)\n    v1 = new Float32Array(stencils.length);\n\n  for (let i = 0; i < v1.length; ++i) v1[i] = 0;\n\n  // At each position, sum up values in spectrum from the slots defined by the stencil\n  // This is the strength of each tone as viewed through the stencil\n  for (let toneIx = 0; toneIx < stencils.length; ++toneIx) {\n    const stencil = stencils[toneIx];\n    for (const binIx of stencil.bins)\n      v1[toneIx] += spectrum[binIx];\n  }\n\n  // Find index of strongest tone\n  let maxVal = Number.MIN_VALUE, maxIx = -1;\n  for (let i = 0; i < v1.length; ++i) {\n    if (v1[i] > maxVal) {\n      maxVal = v1[i];\n      maxIx = i;\n    }\n  }\n\n  // Sum up other values\n  let restSum = 0;\n  for (let i = 0; i < v1.length; ++i) {\n    if (i != maxIx)\n      restSum += v1[i];\n  }\n\n  // Check if highest band is sufficiently stronger than others\n  let ratio = maxVal / restSum;\n  if (ratio >= 0.1) return maxIx;\n  else return -1;\n}\n\nclass Block {\n  constructor(startTonePos, nTones, bytes, crc) {\n    this.startTonePos = startTonePos;\n    this.nTones = nTones;\n    this.bytes = bytes;\n    this.ascii = getAscii(bytes);\n    this.crc = crc;\n    this.valid = crc == getCRC8(bytes);\n  }\n}\n\nclass Decoder {\n  constructor(tones) {\n    this.tones = tones;\n    this.blocks = decode(tones);\n    this.bytes = catBytes(this.blocks);\n    this.ascii = catAscii(this.blocks);\n    this.valid = true;\n    for (const block of this.blocks)\n      if (!block.valid)\n        this.valid = false;\n  }\n}\n\nfunction getAscii(bytes) {\n  let res = \"\";\n  for (const b of bytes) {\n    res += String.fromCodePoint(b);\n  }\n  return res;\n}\n\nfunction catBytes(blocks) {\n  const bytes = [];\n  for (const block of blocks) {\n    bytes.push(...block.bytes);\n  }\n  return bytes;\n}\n\nfunction catAscii(blocks) {\n  let str = \"\";\n  for (const block of blocks) {\n    str += block.ascii;\n  }\n  return str;\n}\n\nfunction decode(tones) {\n  const blocks = [];\n  // Single-byte transmission is 14 tones\n  if (tones.length < 14) return blocks;\n  // Start sequence\n  if (tones[0] != 8 || tones[1] != 0 || tones[2] != 8 || tones[3] != 0) return blocks;\n  // Go block by block\n  let ix = 4;\n  while (true) {\n    const endIx = getBlockEndIx(tones, ix);\n    if (endIx == -1) break;\n    const block = decodeBlock(tones.slice(ix, endIx));\n    block.startTonePos = ix;\n    block.nTones = endIx - ix;\n    blocks.push(block);\n    ix = endIx;\n  }\n  return blocks;\n}\n\nconst toneBits = [\n  [0, 0, 0],\n  [0, 0, 1],\n  [0, 1, 0],\n  [0, 1, 1],\n  [1, 0, 0],\n  [1, 0, 1],\n  [1, 1, 0],\n  [1, 1, 1],\n];\n\nfunction getToneBits(tone) {\n  // For wrong tones (interim 8s): don't crash\n  // We hope that CRC will catch this\n  return toneBits[tone % 8];\n}\n\nfunction decodeBlock(tones, start, end) {\n\n  const seq = tones.slice(start, end);\n\n  const bits = [];\n  for (let i = 0; i < seq.length - 5; ++i)\n    bits.push(...getToneBits(seq[i]));\n  const crcBits = [\n    ...getToneBits(seq[seq.length-4]),\n    ...getToneBits(seq[seq.length-3]),\n    ...getToneBits(seq[seq.length-2]),\n  ];\n  const bytes = getBytes(bits);\n  const crcBytes = getBytes(crcBits);\n  return new Block(start, end - start, bytes, crcBytes[0]);\n}\n\nfunction getBytes(bits) {\n  const res = [];\n  for (let i = 0; i + 8 <= bits.length; i += 8) {\n    let val = 0;\n    for (let j = 0; j < 8; ++j) {\n      val <<= 1;\n      val += bits[i + j];\n    }\n    res.push(val);\n  }\n  return res;\n}\n\nfunction getBlockEndIx(tones, startIx) {\n  // Find next 8NNN8\n  for (let i = startIx + 4; i < tones.length; ++i) {\n    if (tones[i] == 8 && tones[i -4] == 8) {\n      return i + 1;\n    }\n  }\n  return -1;\n}\n\nfunction getCRC8(bytes) {\n\n  let crc = 0;\n  for (const b of bytes)\n    crc = updateCRC(b, crc);\n  return crc;\n\n  function updateCRC(nextByte, crc) {\n    for (let j = 0; j < 8; j++) {\n      let mix = (crc ^ nextByte) & 0x01;\n      crc >>= 1;\n      if (mix)\n        crc ^= 0x8C;\n      nextByte >>= 1;\n    }\n    return crc;\n  }\n}\n\nexport {ToneStencil, Demodulator, Block, Decoder}\n", "const min = Math.min;\nconst max = Math.max;\n\nfunction setString(view, offset, str) {\n  let len = str.length;\n  for (let i = 0; i < len; ++i)\n    view.setUint8(offset + i, str.charCodeAt(i));\n}\n\nclass WAVEncoder {\n  constructor(sampleRate, numChannels) {\n    this.sampleRate = sampleRate;\n    this.numChannels = numChannels;\n    this.numSamples = 0;\n    this.dataViews = [];\n  }\n\n  encode(buffer) {\n    let len = buffer[0].length,\n      nCh = this.numChannels,\n      view = new DataView(new ArrayBuffer(len * nCh * 2)),\n      offset = 0;\n    for (let i = 0; i < len; ++i)\n      for (let ch = 0; ch < nCh; ++ch) {\n        let x = buffer[ch][i] * 0x7fff;\n        view.setInt16(offset, x < 0 ? max(x, -0x8000) : min(x, 0x7fff), true);\n        offset += 2;\n      }\n    this.dataViews.push(view);\n    this.numSamples += len;\n  }\n\n  finish(mimeType) {\n    let dataSize = this.numChannels * this.numSamples * 2,\n      view = new DataView(new ArrayBuffer(44));\n    setString(view, 0, 'RIFF');\n    view.setUint32(4, 36 + dataSize, true);\n    setString(view, 8, 'WAVE');\n    setString(view, 12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, this.numChannels, true);\n    view.setUint32(24, this.sampleRate, true);\n    view.setUint32(28, this.sampleRate * 4, true);\n    view.setUint16(32, this.numChannels * 2, true);\n    view.setUint16(34, 16, true);\n    setString(view, 36, 'data');\n    view.setUint32(40, dataSize, true);\n    this.dataViews.unshift(view);\n    let blob = new Blob(this.dataViews, {type: 'audio/wav'});\n    this.cleanup();\n    return blob;\n  }\n\n  cancel() {\n    this.cleanup();\n  };\n\n  cleanup() {\n    delete this.dataViews;\n  }\n\n  canEncode() {\n    return this.hasOwnProperty(\"dataViews\");\n  }\n}\n\nexport {WAVEncoder}\n", "/*\n * FFT code extracted from the DSP.js library:\n * https://github.com/corbanbrook/dsp.js/\n * Used here under the terms of the MIT license\n *\n * DSP.js - a comprehensive digital signal processing  library for javascript\n *\n * Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.\n * Copyright 2010 Corban Brook. All rights reserved.\n *\n */\n\n\n// Fourier Transform Module used by DFT, FFT, RFFT\nfunction FourierTransform(bufferSize, sampleRate) {\n  this.bufferSize = bufferSize;\n  this.sampleRate = sampleRate;\n  this.bandwidth = 2 / bufferSize * sampleRate / 2;\n\n  this.spectrum = new Float64Array(bufferSize / 2);\n  this.real = new Float64Array(bufferSize);\n  this.imag = new Float64Array(bufferSize);\n\n  this.peakBand = 0;\n  this.peak = 0;\n\n  /**\n   * Calculates the *middle* frequency of an FFT band.\n   *\n   * @param {Number} index The index of the FFT band.\n   *\n   * @returns The middle frequency in Hz.\n   */\n  this.getBandFrequency = function (index) {\n    return this.bandwidth * index + this.bandwidth / 2;\n  };\n\n  this.calculateSpectrum = function () {\n    let spectrum = this.spectrum,\n      real = this.real,\n      imag = this.imag,\n      bSi = 2 / this.bufferSize,\n      sqrt = Math.sqrt,\n      rval,\n      ival,\n      mag;\n\n    for (let i = 0, N = bufferSize / 2; i < N; i++) {\n      rval = real[i];\n      ival = imag[i];\n      mag = bSi * sqrt(rval * rval + ival * ival);\n\n      if (mag > this.peak) {\n        this.peakBand = i;\n        this.peak = mag;\n      }\n\n      spectrum[i] = mag;\n    }\n  };\n}\n\nclass FFT {\n  /**\n   * FFT is a class for calculating the Discrete Fourier Transform of a signal\n   * with the Fast Fourier Transform algorithm.\n   *\n   * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2\n   * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)\n   *\n   * @constructor\n   */\n  constructor(bufferSize, sampleRate) {\n    FourierTransform.call(this, bufferSize, sampleRate);\n\n    this.reverseTable = new Uint32Array(bufferSize);\n\n    let limit = 1;\n    let bit = bufferSize >> 1;\n\n    let i;\n\n    while (limit < bufferSize) {\n      for (i = 0; i < limit; i++) {\n        this.reverseTable[i + limit] = this.reverseTable[i] + bit;\n      }\n\n      limit = limit << 1;\n      bit = bit >> 1;\n    }\n\n    this.sinTable = new Float64Array(bufferSize);\n    this.cosTable = new Float64Array(bufferSize);\n\n    for (i = 0; i < bufferSize; i++) {\n      this.sinTable[i] = Math.sin(-Math.PI / i);\n      this.cosTable[i] = Math.cos(-Math.PI / i);\n    }\n  }\n\n  /**\n   * Performs a forward transform on the sample buffer.\n   * Converts a time domain signal to frequency domain spectra.\n   *\n   * @param {Array} buffer The sample buffer. Buffer Length must be power of 2\n   *\n   * @returns The frequency spectrum array\n   */\n  forward(buffer) {\n    // Locally scope variables for speed up\n    let bufferSize = this.bufferSize,\n      cosTable = this.cosTable,\n      sinTable = this.sinTable,\n      reverseTable = this.reverseTable,\n      real = this.real,\n      imag = this.imag,\n      spectrum = this.spectrum;\n\n    let k = Math.floor(Math.log(bufferSize) / Math.LN2);\n\n    if (Math.pow(2, k) !== bufferSize) {\n      throw \"Invalid buffer size, must be a power of 2.\";\n    }\n    if (bufferSize !== buffer.length) {\n      throw \"Supplied buffer is not the same size as defined FFT. FFT Size: \" + bufferSize + \" Buffer Size: \" + buffer.length;\n    }\n\n    let halfSize = 1,\n      phaseShiftStepReal,\n      phaseShiftStepImag,\n      currentPhaseShiftReal,\n      currentPhaseShiftImag,\n      off,\n      tr,\n      ti,\n      tmpReal,\n      i;\n\n    for (i = 0; i < bufferSize; i++) {\n      real[i] = buffer[reverseTable[i]];\n      imag[i] = 0;\n    }\n\n    while (halfSize < bufferSize) {\n      //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);\n      //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);\n      phaseShiftStepReal = cosTable[halfSize];\n      phaseShiftStepImag = sinTable[halfSize];\n\n      currentPhaseShiftReal = 1;\n      currentPhaseShiftImag = 0;\n\n      for (let fftStep = 0; fftStep < halfSize; fftStep++) {\n        i = fftStep;\n\n        while (i < bufferSize) {\n          off = i + halfSize;\n          tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);\n          ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);\n\n          real[off] = real[i] - tr;\n          imag[off] = imag[i] - ti;\n          real[i] += tr;\n          imag[i] += ti;\n\n          i += halfSize << 1;\n        }\n\n        tmpReal = currentPhaseShiftReal;\n        currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);\n        currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);\n      }\n\n      halfSize = halfSize << 1;\n    }\n\n    return this.calculateSpectrum();\n  }\n\n  inverse(real, imag) {\n    // Locally scope variables for speed up\n    let bufferSize = this.bufferSize,\n      cosTable = this.cosTable,\n      sinTable = this.sinTable,\n      reverseTable = this.reverseTable,\n      spectrum = this.spectrum;\n\n    real = real || this.real;\n    imag = imag || this.imag;\n\n    let halfSize = 1,\n      phaseShiftStepReal,\n      phaseShiftStepImag,\n      currentPhaseShiftReal,\n      currentPhaseShiftImag,\n      off,\n      tr,\n      ti,\n      tmpReal,\n      i;\n\n    for (i = 0; i < bufferSize; i++) {\n      imag[i] *= -1;\n    }\n\n    let revReal = new Float64Array(bufferSize);\n    let revImag = new Float64Array(bufferSize);\n\n    for (i = 0; i < real.length; i++) {\n      revReal[i] = real[reverseTable[i]];\n      revImag[i] = imag[reverseTable[i]];\n    }\n\n    real = revReal;\n    imag = revImag;\n\n    while (halfSize < bufferSize) {\n      phaseShiftStepReal = cosTable[halfSize];\n      phaseShiftStepImag = sinTable[halfSize];\n      currentPhaseShiftReal = 1;\n      currentPhaseShiftImag = 0;\n\n      for (let fftStep = 0; fftStep < halfSize; fftStep++) {\n        i = fftStep;\n\n        while (i < bufferSize) {\n          off = i + halfSize;\n          tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);\n          ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);\n\n          real[off] = real[i] - tr;\n          imag[off] = imag[i] - ti;\n          real[i] += tr;\n          imag[i] += ti;\n\n          i += halfSize << 1;\n        }\n\n        tmpReal = currentPhaseShiftReal;\n        currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);\n        currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);\n      }\n\n      halfSize = halfSize << 1;\n    }\n\n    let buffer = new Float64Array(bufferSize); // this should be reused instead\n    for (i = 0; i < bufferSize; i++) {\n      buffer[i] = real[i] / bufferSize;\n    }\n\n    return buffer;\n  }\n}\n\nexport {FFT}\n\n", "// With love from https://gist.github.com/jonleighton/958841\n// Copyright 2011 Jon Leighton\n// MIT license\nfunction toBase64(bytes) {\n  let base64 = '';\n  let encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  let byteLength = bytes.length;\n  let byteRemainder = byteLength % 3;\n  let mainLength = byteLength - byteRemainder;\n  let a, b, c, d;\n  let chunk;\n  // Main loop deals with bytes in chunks of 3\n  for (let i = 0; i < mainLength; i = i + 3) {\n    // Combine the three bytes into a single integer\n    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n    // Use bitmasks to extract 6-bit segments from the triplet\n    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n    d = chunk & 63;               // 63       = 2^6 - 1\n    // Convert the raw binary segments to the appropriate ASCII encoding\n    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n  }\n  // Deal with the remaining bytes and padding\n  if (byteRemainder == 1) {\n    chunk = bytes[mainLength];\n    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n    // Set the 4 least significant bits to zero\n    b = (chunk & 3) << 4; // 3   = 2^2 - 1\n    base64 += encodings[a] + encodings[b] + '==';\n  } else if (byteRemainder == 2) {\n    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n    // Set the 2 least significant bits to zero\n    c = (chunk & 15) << 2; // 15    = 2^4 - 1\n    base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n  }\n  let res = \"\";\n  for (let i = 0; i < base64.length; ++i) {\n    if (i > 0 && (i % 76) == 0) res += \"\\n\";\n    res += base64[i];\n  }\n  return res;\n}\n\n// With love from https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js\n// Copyright 2011, Daniel Guerrero\nfunction fromBase64(input, uarray, offset) {\n  const encodings = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  //get last chars to see if are valid\n  input = removePaddingChars(input);\n  input = removePaddingChars(input);\n  let bytes = parseInt((input.length / 4) * 3, 10);\n  let chr1, chr2, chr3;\n  let enc1, enc2, enc3, enc4;\n  let i = 0;\n  let j = 0;\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n  for (i = 0; i < bytes; i += 3) {\n    //get the 3 octects in 4 ascii chars\n    enc1 = encodings.indexOf(input.charAt(j++));\n    enc2 = encodings.indexOf(input.charAt(j++));\n    enc3 = encodings.indexOf(input.charAt(j++));\n    enc4 = encodings.indexOf(input.charAt(j++));\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n    uarray[i + offset] = chr1;\n    if (enc3 != 64) uarray[i + 1 + offset] = chr2;\n    if (enc4 != 64) uarray[i + 2 + offset] = chr3;\n  }\n}\n\nexport {fromBase64, toBase64};\n", "function decodeDateTime(bytes) {\n  let year = (bytes[0] & 0b11111100) >> 2;\n  year += 2020;\n  let month = ((bytes[0] & 0b00000011) << 2) + ((bytes[1] & 0b11000000) >> 6);\n  let day = (bytes[1] & 0b00111110) >> 1;\n  let hour = ((bytes[1] & 0b00000001) << 4) + ((bytes[2] & 0b11110000) >> 4);\n  let minute = ((bytes[2] & 0b00001111) << 2) + ((bytes[3] & 0b11000000) >> 6);\n  let second = (bytes[3] & 0b00111111);\n  return new Date(year, month - 1, day, hour, minute, second);\n}\n\n// uint32_t second : 6;    // 0-59\n// uint32_t minute : 6;    // 0-59\n// uint32_t hour : 5;      // 0-23\n// uint32_t day : 5;       // 1-31\n// uint32_t month : 4;     // 1-12\n// uint32_t year : 6;      // 0-63 (representing 2020-2083)\n\n\nfunction dateToIso(date) {\n  // 2012-01-01T00:00:00\n  let res = date.getFullYear() + \"-\" + (date.getMonth() + 1).toString().padStart(2, \"0\") + \"-\";\n  res += date.getDate().toString().padStart(2, \"0\") + \"T\";\n  res += date.getHours().toString().padStart(2, \"0\") + \":\";\n  res += date.getMinutes().toString().padStart(2, \"0\") + \":\";\n  res += date.getSeconds().toString().padStart(2, \"0\");\n  return res;\n}\n\nexport {decodeDateTime, dateToIso}\n", "import {decodeDateTime, dateToIso} from \"./content-shared.js\";\n\nfunction interpretActivity(bytes, elmRes, elmLnk) {\n\n  if (bytes.length <= 2 || bytes[0] != 0x27 || bytes[1] != 0x00)\n    return false;\n\n  const itmLen = 9;\n  const items = [];\n  for (let ix = 2; ix < bytes.length; ix += itmLen) {\n    const itmBytes = bytes.slice(ix, ix + itmLen);\n    items.push(new DecodedActivity(itmBytes));\n  }\n  let tableTxt = \"time\\tactivity_code\\tactivity_name\\ttotal_duration\\tpause_duration\\n\";\n  for (const itm of items) {\n    tableTxt += dateToIso(itm.start) + \"\\t\" + itm.typeNum + \"\\t\" + itm.type + \"\\t\";\n    tableTxt += secsToDuration(itm.totalSec) + \"\\t\" + secsToDuration(itm.pauseSec);\n    tableTxt += \"\\n\";\n  }\n  elmRes.innerHTML = \"<pre></pre>\";\n  elmRes.querySelector(\"pre\").innerText = tableTxt;\n  elmLnk.innerText = \"Activity\";\n  return true;\n}\n\nclass DecodedActivity {\n  constructor(bytes) {\n    // watch_date_time start_time;\n    // uint16_t total_sec;\n    // uint16_t pause_sec;\n    // uint8_t activity_type;\n\n    this.start = decodeDateTime(bytes);\n    this.totalSec = bytes[4] * 256 + bytes[5];\n    this.pauseSec = bytes[6] * 256 + bytes[7];\n    this.typeNum = bytes[8];\n    this.type = \"UNKNOWN\";\n    if (this.typeNum < activities.length)\n      this.type = activities[this.typeNum];\n  }\n}\n\nconst activities = [\"BIKE\", \"WALK\", \"RUN\", \"DANCE\", \"YOGA\", \"CROSSFIT\", \"SWIM\",\n  \"ELLIPTICAL\", \"GYM\", \"ROW\", \"SOCCER\", \"FOOTBALL\", \"BALLGAME\", \"SKI\",\n];\n\nfunction secsToDuration(val) {\n  let secs = val % 60;\n  val -= secs;\n  val /= 60;\n  let mins = val % 60;\n  val -= mins;\n  let hours = val / 60;\n  let res = mins.toString().padStart(2, \"0\") + \":\" + secs.toString().padStart(2, \"0\");\n  if (hours == 0) return res;\n  res = hours.toString() + \":\" + res;\n  return res;\n}\n\n\nexport {interpretActivity}\n", "import {decodeDateTime, dateToIso} from \"./content-shared.js\";\n\nfunction interpretNanosecIni(bytes, elmRes, elmLnk) {\n\n  if (bytes.length < 18 + 2 || bytes[0] != 0xc0 || bytes[1] != 0x00)\n    return false;\n\n  const info = new DecodedNanosecIni(bytes.slice(2, bytes.length));\n  let txt = \"\";\n  txt += \"Correction profile:     \" + info.correctionProfile + \" (\" + info.correctionPorfileStr + \")\\n\";\n  txt += \"Frequency correction:   \" + (info.freqCorrection / 100).toFixed(2) + \"\\n\";\n  txt += \"Center temperature:     \" + (info.centerTemperature / 100).toFixed(2) + \"\\n\";\n  txt += \"Quadratic temp coeff:  -\" + info.quadraticTempCo + \"e-5\\n\";\n  txt += \"Cubic temp coeff:       \" + info.cubicTempCo + \"e-7\\n\";\n  txt += \"Correction cadence:     \" + info.correctionCadence + \"\\n\";\n  txt += \"Last correction time:   \" + dateToIso(info.lastCorrectionTime) + \"\\n\";\n  txt += \"Annual aging:           \" + (info.annualAgingPPA / 100).toFixed(2) + \" PPA\\n\";\n\n  elmRes.innerHTML = \"<pre></pre>\";\n  elmRes.querySelector(\"pre\").innerText = txt;\n  elmLnk.innerText = \"Nanosec.ini\";\n  return true;\n\n}\n\n// int8_t correction_profile;\n// int16_t freq_correction; // Static correction - multiplied by 100\n// int16_t center_temperature; // Multiplied by 100, +25.0 -> +2500\n// int16_t quadratic_tempco; // 0.034 -> 3400, multiplied by 100000. Stored positive, used as negative.\n// int16_t cubic_tempco; // default 0, 0.000136 -> 1360, multiplied by 10000000. Stored positive, used positive.\n// int8_t correction_cadence;\n// uint32_t last_correction_time; // Not used at the moment - but will in the future\n// int16_t aging_ppm_pa; // multiplied by 100. Aging per year.\n\nclass DecodedNanosecIni {\n  constructor(bytes) {\n    this.correctionProfile = bytes[0];\n    this.correctionPorfileStr = profiles[this.correctionProfile];\n    this.freqCorrection = (bytes[3] << 8) + bytes[2];\n    this.centerTemperature = (bytes[5] << 8) + bytes[4];\n    this.quadraticTempCo = (bytes[7] << 8) + bytes[6];\n    this.cubicTempCo = (bytes[9] << 8) + bytes[8];\n    this.correctionCadence = bytes[10];\n    const lastCurrTimeUnix = (bytes[15] << 24) + (bytes[14] << 16) + (bytes[13] << 8) + bytes[12];\n    this.lastCorrectionTime = new Date(lastCurrTimeUnix * 1000);\n    this.annualAgingPPA = (bytes[17] << 8) + bytes[16];\n  }\n}\n\nconst profiles = [\n  \"static hardware correction\",\n  \"static correction with dithering\",\n  \"datasheet quadratic correction\",\n  \"cubic correction conservative\",\n  \"cubic correction finetuned\",\n];\n\nexport {interpretNanosecIni}\n", "function interpretAscii(bytes, elmRes, elmLnk) {\n\n  let canBeAscii = true;\n  for (const b of bytes)\n    if (b == 0 || b > 127) canBeAscii = false;\n  if (!canBeAscii) return false;\n\n  let ascii = \"\";\n  for (const b of bytes) {\n    ascii += String.fromCodePoint(b);\n  }\n\n  elmRes.innerHTML = \"<pre></pre>\";\n  elmRes.querySelector(\"pre\").innerText = ascii;\n  elmLnk.innerText = \"ASCII\";\n  return true;\n}\n\nexport {interpretAscii}\n", "import {interpretActivity} from \"./content-activity.js\";\nimport {interpretNanosecIni} from \"./content-nanosec.js\";\nimport {interpretAscii} from \"./content-ascii.js\";\n\nconst parserFuns = [\n  interpretActivity,\n  interpretNanosecIni,\n  interpretAscii,\n];\n\nfunction interpretContent(bytes, elmRes, elmLnk) {\n  for (const fun of parserFuns) {\n    if (fun(bytes, elmRes, elmLnk))\n      return true;\n  }\n  return false;\n}\n\nexport {interpretContent}\n", "import {ToneStencil, Demodulator, Block, Decoder} from \"./chirpy-rx.js\";\nimport {WAVEncoder} from \"./wav-encoder.js\";\nimport {FFT} from \"./fft.js\";\nimport {runChirpyRxTests} from \"./chirpy-rx-tests.js\";\nimport {toBase64} from \"./base64.js\";\nimport {interpretContent} from \"./content.js\";\n\nconst showTest = false;\nconst testFileName = \"data-06.wav\";\n\nconst gainVal = 10;\nconst toneRate = 64/3;\nconst baseFreq = 2500;\nconst freqStep = 250;\nconst nFreqs = 9;\nconst fftSize = 512;\n\nlet audioCtx, stream, gain, source, wavEncoder, mediaRecorder, recordedChunks;\nlet chunks, nSamples, sampleRate;\nlet spectra;\nlet demodulator, startMsec, tones, decoder;\n\nconst elms = {\n  btnAudio: null, ctrlAudioTop: null, lblLength: null, lnkWav: null, lnkTest: null,\n  ctrlDecoding: null, decodingStatus: null, decodingRes: null,\n  lnkTones: null, lnkBlocks: null, lnkBase64: null, lnkContent: null,\n  resTones: null, resBlocks: null, resBase64: null, resContent: null,\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\n  initUI();\n\n});\n\nfunction initUI() {\n  for (const key in elms)\n    elms[key] = document.getElementById(key);\n  elms.btnAudio.addEventListener(\"click\", onBtnAudioClick);\n  if (showTest) {\n    elms.lnkTest.classList.add(\"visible\");\n    elms.lnkTest.addEventListener(\"click\", onTestClick);\n  }\n  elms.lnkTones.addEventListener(\"click\", () => setCtrlDecodingTab(\"tones\"));\n  elms.lnkBlocks.addEventListener(\"click\", () => setCtrlDecodingTab(\"blocks\"));\n  elms.lnkBase64.addEventListener(\"click\", () => setCtrlDecodingTab(\"base64\"));\n  elms.lnkContent.addEventListener(\"click\", () => setCtrlDecodingTab(\"content\"));\n}\n\nfunction setCtrlDecodingTab(tab) {\n  [\"tones\", \"blocks\", \"base64\", \"content\"].forEach(cls => elms.ctrlDecoding.classList.remove(cls));\n  elms.ctrlDecoding.classList.add(tab);\n}\n\nfunction onTestClick() {\n  audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n  gain = audioCtx.createGain();\n  gain.connect(audioCtx.destination);\n  gain.gain.setValueAtTime(gainVal, audioCtx.currentTime);\n\n  const req = new XMLHttpRequest();\n  req.open('GET', testFileName, true);\n  req.responseType = 'arraybuffer';\n  req.onload = function () {\n    const audioData = req.response;\n    audioCtx.decodeAudioData(audioData).then(buf => {\n      const data = buf.getChannelData(0);\n      chunks = [];\n      sampleRate = buf.sampleRate;\n      nSamples = data.length;\n      let pos = 0;\n      while (pos < data.length) {\n        const chunkSize = Math.min(4096, data.length - pos);\n        const chunk = new Float32Array(chunkSize);\n        for (let i = 0; i < chunkSize; ++i) {\n          chunk[i] = data[pos + i];\n        }\n        chunks.push(chunk);\n        pos += chunkSize;\n      }\n      setAutdioBtnClass(\"done\");\n      elms.lnkTest.classList.remove(\"visible\");\n      elms.ctrlAudioTop.innerText = \"Loaded audio file\";\n      startProcessing();\n    }).catch(err => {\n      alert(\"Error decoding audio data: \" + err.err);\n    });\n  }\n  req.send();\n}\n\nfunction setAutdioBtnClass(cls) {\n  [\"enable\", \"record\", \"stop\", \"done\"].forEach(cls => elms.btnAudio.classList.remove(cls));\n  elms.btnAudio.classList.add(cls);\n}\n\nfunction onBtnAudioClick() {\n  if (elms.btnAudio.classList.contains(\"enable\")) {\n    navigator.mediaDevices.getUserMedia({audio: true}).then((s) => {\n      audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      stream = s;\n      setAutdioBtnClass(\"record\");\n      elms.ctrlAudioTop.innerText = \"Press to record transmission\";\n    }).catch((err) => {\n      elms.ctrlAudioTop.innerText = \"Failed to enable microphone ;-(\";\n    });\n  } else if (elms.btnAudio.classList.contains(\"record\")) {\n    elms.lnkTest.classList.remove(\"visible\");\n    source = audioCtx.createMediaStreamSource(stream);\n    gain = audioCtx.createGain();\n    source.connect(gain);\n\n    // MediaRecorder setup\n    recordedChunks = [];\n    mediaRecorder = new MediaRecorder(stream);\n\n    mediaRecorder.ondataavailable = function(event) {\n      if (event.data.size > 0) {\n        recordedChunks.push(event.data);\n      }\n    };\n\n    mediaRecorder.onstop = function() {\n      const webmBlob = new Blob(recordedChunks, { 'type' : 'audio/webm' });\n\n      webmBlob.arrayBuffer().then(arrayBuffer => {\n          audioCtx.decodeAudioData(arrayBuffer).then(audioBuffer => {\n              const data = audioBuffer.getChannelData(0);\n              sampleRate = audioBuffer.sampleRate;\n\n              // Use WAVEncoder to create a WAV blob\n              wavEncoder = new WAVEncoder(audioBuffer.sampleRate, 1); // Initialize WAVEncoder\n              wavEncoder.encode([data]); // Encode the audio data\n              const wavBlob = wavEncoder.finish(); // Get the WAV blob\n\n              const url = window.URL.createObjectURL(wavBlob); // Use WAV blob for URL\n              elms.lnkWav.href = url;\n              elms.lnkWav.download = \"chirpy.wav\"; // Change extension back to .wav\n              elms.lnkWav.style.display = \"inline\";\n\n              // Continue with processing (chunks and startProcessing)\n              chunks = [];\n              let pos = 0;\n              while (pos < data.length) {\n                  const chunkSize = Math.min(4096, data.length - pos);\n                  const chunk = new Float32Array(chunkSize);\n                  for (let i = 0; i < chunkSize; ++i) {\n                      chunk[i] = data[pos + i];\n                  }\n                  chunks.push(chunk);\n                  pos += chunkSize;\n              }\n              startProcessing();\n          }).catch(err => {\n              console.error(\"Error decoding recorded audio data:\", err);\n              elms.decodingStatus.innerText = \"Failed to process recording.\";\n          });\n      });\n    };\n\n    mediaRecorder.start(); // Start recording\n\n    setAutdioBtnClass(\"stop\");\n    elms.ctrlAudioTop.innerText = \"Press to finish recording\";\n    const startTime = new Date();\n    updateTime();\n    function updateTime() {\n      const elapsed = new Date() - startTime;\n      let secs = Math.floor(elapsed / 1000);\n      let mins = Math.floor(secs / 60);\n      secs -= mins * 60;\n      elms.lblLength.innerText = mins + \":\" + secs.toString().padStart(2, '0');\n      if (elms.btnAudio.classList.contains(\"stop\")) {\n        setTimeout(updateTime, 50);\n      }\n    }\n  }\n  else if (elms.btnAudio.classList.contains(\"stop\")) {\n    setAutdioBtnClass(\"done\");\n    elms.ctrlAudioTop.innerText = \"Recording finished\";\n    // Clean up\n    source.disconnect();\n    mediaRecorder.stop();\n  }\n}\n\nfunction startProcessing() {\n\n  elms.ctrlDecoding.classList.add(\"visible\");\n  const fft = new FFT(fftSize, sampleRate);\n  spectra = [];\n\n  let chunkIx = 0, posInChunk = 0;\n  const frame = new Float32Array(fftSize);\n  const framesPerIter = 1000;\n  decodeSome();\n\n  function decodeSome() {\n\n    let dataOver = false;\n\n    // Process several FFT rounds\n    for (let fc = 0; fc < framesPerIter && !dataOver; ++fc) {\n      // Gather data for this FFT round\n      for (let i = 0; i < fftSize; ++i) {\n        if (posInChunk == chunks[chunkIx].length) {\n          posInChunk = 0;\n          chunkIx += 1;\n        }\n        if (chunkIx == chunks.length) {\n          dataOver = true;\n          break;\n        }\n        frame[i] = chunks[chunkIx][posInChunk] * gainVal;\n        ++posInChunk;\n      }\n      if (dataOver) break;\n      // Do FFT; save spectrum\n      fft.forward(frame);\n      let s = new Float32Array(fft.spectrum.length);\n      for (let i = 0; i < s.length; ++i) s[i] = fft.spectrum[i];\n      spectra.push(s);\n    }\n\n    if (dataOver) startDemodulating();\n    else {\n      setTimeout(decodeSome, 10);\n    }\n  }\n}\n\nfunction startDemodulating() {\n\n  demodulator = new Demodulator({\n    sampleRate,\n    fftSize,\n    toneRate,\n    baseFreq,\n    freqStep,\n    nFreqs});\n\n  startMsec = demodulator.findStartMsec(spectra);\n  if (startMsec == -1) {\n    elms.decodingStatus.innerText = \"No message found.\";\n    elms.resTones.innerHTML += \"<p>No Start-Of-Message sequence detected. Cannot decode transmission.</p>\";\n    return;\n  }\n\n  tones = [];\n  let tonePos = 0;\n  const tonesPerIter = 500;\n  const recLenMsec = Math.round(nSamples / sampleRate * 1000);\n  demodulateSome();\n\n  function demodulateSome() {\n    for (let tc = 0; tc < tonesPerIter; ++tc) {\n      const msec = startMsec + tonePos * demodulator.toneLenMsec;\n      if (msec + 200 > recLenMsec) {\n        decodeTones(startMsec, null);\n        return;\n      }\n      const tone = demodulator.detecToneAt(spectra, msec);\n      tones.push(tone);\n      if (doesEndInEOM(tones, demodulator.symFreqs.length - 1)) {\n        decodeTones(startMsec, msec);\n        return;\n      }\n      ++tonePos;\n    }\n    setTimeout(demodulateSome, 10);\n  }\n\n  function doesEndInEOM(tones, signalToneIx) {\n    if (tones.length < 3) return false;\n    for (let i = 0; i < 3; ++i) {\n      if (tones[tones.length - i - 1] != signalToneIx) return false;\n    }\n    return true;\n  }\n}\n\nfunction decodeTones(startMsec, endMsec) {\n  console.log(\"Detected tones:\", tones);\n  const startSecStr = (startMsec / 1000).toFixed(2);\n  if (!endMsec) {\n    elms.resTones.innerHTML += `<p>Start of message: ${startSecStr}<br/>No End-Of-Message sequence detected</p>`;\n  }\n  else {\n    const endSecStr = (endMsec / 1000).toFixed(2);\n    elms.resTones.innerHTML += `<p>Start of message: ${startSecStr}<br/>End of message: ${endSecStr}</p>`;\n  }\n  // Display tones\n  let tonesStr = \"\";\n  for (const t of tones) {\n    if (tonesStr != \"\") tonesStr += \" \";\n    tonesStr += t;\n  }\n  elms.resTones.innerHTML += `<pre>${tonesStr}</pre>`;\n\n  // Decode, and display decoded blocks\n  decoder = new Decoder(tones);\n  let blocksHtml = \"\";\n  for (let i = 0; i < decoder.blocks.length; ++i) {\n    const block = decoder.blocks[i];\n    if (block.valid) blocksHtml += `<span class='valid'>Block ${i} VALID</span>`;\n    else blocksHtml += `<span class='invalid'>Block ${i} INVALID</span>`;\n    blocksHtml += \"\\nTones:\";\n    for (let j = block.startTonePos; j < block.startTonePos + block.nTones; ++j)\n      blocksHtml += \" \" + tones[j];\n    blocksHtml += \"\\nBytes:\";\n    for (const b of block.bytes)\n      blocksHtml += \" 0x\" + b.toString(16).padStart(2, \"0\");\n    blocksHtml += \"\\nCRC: 0x\" + block.crc.toString(16).padStart(2, \"0\") + \"\\n\\n\";\n  }\n  elms.resBlocks.innerHTML = `<pre>${blocksHtml}</pre>`;\n  elms.lnkBlocks.classList.add(\"visible\");\n  setCtrlDecodingTab(\"blocks\");\n\n  if (!decoder.valid) {\n    elms.decodingStatus.innerText = \"Message cannot be reconstructed: invalid CRC in one or more blocks.\";\n    return;\n  }\n  // Display decoded binary as Base64\n  const base64 = toBase64(decoder.bytes);\n  elms.resBase64.innerHTML = `\n<p>\n  This is the transmission's data content encoded in Base64. If you're not sure how to decode it,\n  you can use an online tool like\n  <a href=\"https://base64.guru/converter/decode\" target=\"_blank\" rel=\"noreferrer\">Base64.guru</a>.\n</p>\n<pre>${base64}</pre>`;\n  elms.lnkBase64.classList.add(\"visible\");\n  setCtrlDecodingTab(\"base64\");\n  elms.decodingStatus.innerText = \"Message successfully decoded.\";\n\n  // Interpret content as a specific format\n  if (interpretContent(decoder.bytes, elms.resContent, elms.lnkContent)) {\n    elms.lnkContent.classList.add(\"visible\");\n    setCtrlDecodingTab(\"content\");\n  }\n}\n\n"],
  "mappings": "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",
  "names": ["sampleRate", "fftSize", "toneRate", "baseFreq", "freqStep", "nFreqs", "spectra", "tones", "crc", "sampleRate", "sampleRate", "cls", "tones", "startMsec"]
}
